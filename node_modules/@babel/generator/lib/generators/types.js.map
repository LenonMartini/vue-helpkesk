{"version":3,"names":["_t","require","_jsesc","isAssignmentPattern","isIdentifier","Identifier","node","_node$loc","sourceIdentifierName","loc","identifierName","name","word","ArgumentPlaceholder","token","RestElement","print","argument","ObjectExpression","props","properties","length","space","printList","indent","statement","sourceWithOffset","ObjectMethod","printJoin","decorators","_methodHead","body","ObjectProperty","computed","key","value","left","shorthand","ArrayExpression","elems","elements","len","i","elem","RecordExpression","startToken","endToken","format","recordAndTupleSyntaxType","Error","JSON","stringify","TupleExpression","RegExpLiteral","pattern","flags","BooleanLiteral","NullLiteral","NumericLiteral","raw","getPossibleRaw","opts","jsescOption","numbers","number","jsesc","minified","StringLiteral","undefined","val","BigIntLiteral","DecimalLiteral","validTopicTokenSet","Set","TopicReference","topicToken","has","givenTopicTokenJSON","validTopics","Array","from","v","join","PipelineTopicExpression","expression","PipelineBareFunction","callee","PipelinePrimaryTopicReference"],"sources":["../../src/generators/types.ts"],"sourcesContent":["import type Printer from \"../printer\";\nimport { isAssignmentPattern, isIdentifier } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport jsesc from \"jsesc\";\n\nexport function Identifier(this: Printer, node: t.Identifier) {\n  this.sourceIdentifierName(\n    // @ts-expect-error Undocumented property identifierName\n    node.loc?.identifierName || node.name,\n  );\n  this.word(node.name);\n}\n\nexport function ArgumentPlaceholder(this: Printer) {\n  this.token(\"?\");\n}\n\nexport function RestElement(this: Printer, node: t.RestElement) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nexport { RestElement as SpreadElement };\n\nexport function ObjectExpression(this: Printer, node: t.ObjectExpression) {\n  const props = node.properties;\n\n  this.token(\"{\");\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, { indent: true, statement: true });\n    this.space();\n  }\n\n  this.sourceWithOffset(\"end\", node.loc, 0, -1);\n\n  this.token(\"}\");\n}\n\nexport { ObjectExpression as ObjectPattern };\n\nexport function ObjectMethod(this: Printer, node: t.ObjectMethod) {\n  this.printJoin(node.decorators, node);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function ObjectProperty(this: Printer, node: t.ObjectProperty) {\n  this.printJoin(node.decorators, node);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key, node);\n    this.token(\"]\");\n  } else {\n    // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`\n    if (\n      isAssignmentPattern(node.value) &&\n      isIdentifier(node.key) &&\n      // @ts-expect-error todo(flow->ts) `.name` does not exist on some types in union\n      node.key.name === node.value.left.name\n    ) {\n      this.print(node.value, node);\n      return;\n    }\n\n    this.print(node.key, node);\n\n    // shorthand!\n    if (\n      node.shorthand &&\n      isIdentifier(node.key) &&\n      isIdentifier(node.value) &&\n      node.key.name === node.value.name\n    ) {\n      return;\n    }\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nexport function ArrayExpression(this: Printer, node: t.ArrayExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  this.token(\"[\");\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.token(\",\");\n    } else {\n      // If the array expression ends with a hole, that hole\n      // will be ignored by the interpreter, but if it ends with\n      // two (or more) holes, we need to write out two (or more)\n      // commas so that the resulting code is interpreted with\n      // both (all) of the holes.\n      this.token(\",\");\n    }\n  }\n\n  this.token(\"]\");\n}\n\nexport { ArrayExpression as ArrayPattern };\n\nexport function RecordExpression(this: Printer, node: t.RecordExpression) {\n  const props = node.properties;\n\n  let startToken;\n  let endToken;\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"{|\";\n    endToken = \"|}\";\n  } else if (\n    this.format.recordAndTupleSyntaxType !== \"hash\" &&\n    this.format.recordAndTupleSyntaxType != null\n  ) {\n    throw new Error(\n      `The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(\n        this.format.recordAndTupleSyntaxType,\n      )} received).`,\n    );\n  } else {\n    startToken = \"#{\";\n    endToken = \"}\";\n  }\n\n  this.token(startToken);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, { indent: true, statement: true });\n    this.space();\n  }\n  this.token(endToken);\n}\n\nexport function TupleExpression(this: Printer, node: t.TupleExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  let startToken;\n  let endToken;\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"[|\";\n    endToken = \"|]\";\n  } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n    startToken = \"#[\";\n    endToken = \"]\";\n  } else {\n    throw new Error(\n      `${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`,\n    );\n  }\n\n  this.token(startToken);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.token(\",\");\n    }\n  }\n\n  this.token(endToken);\n}\n\nexport function RegExpLiteral(this: Printer, node: t.RegExpLiteral) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\n\nexport function BooleanLiteral(this: Printer, node: t.BooleanLiteral) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteral(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function NumericLiteral(this: Printer, node: t.NumericLiteral) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value + \"\";\n  if (opts.numbers) {\n    this.number(jsesc(node.value, opts));\n  } else if (raw == null) {\n    this.number(value); // normalize\n  } else if (this.format.minified) {\n    this.number(raw.length < value.length ? raw : value);\n  } else {\n    this.number(raw);\n  }\n}\n\nexport function StringLiteral(this: Printer, node: t.StringLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const val = jsesc(node.value, this.format.jsescOption);\n\n  this.token(val);\n}\n\nexport function BigIntLiteral(this: Printer, node: t.BigIntLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\n\nexport function DecimalLiteral(this: Printer, node: t.DecimalLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"m\");\n}\n\n// Hack pipe operator\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\nexport function TopicReference(this: Printer) {\n  const { topicToken } = this.format;\n\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(\n      `The \"topicToken\" generator option must be one of ` +\n        `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`,\n    );\n  }\n}\n\n// Smart-mix pipe operator\nexport function PipelineTopicExpression(\n  this: Printer,\n  node: t.PipelineTopicExpression,\n) {\n  this.print(node.expression, node);\n}\n\nexport function PipelineBareFunction(\n  this: Print/**
 * Return array of browsers by selection queries.
 *
 * ```js
 * browserslist('IE >= 10, IE 8') //=> ['ie 11', 'ie 10', 'ie 8']
 * ```
 *
 * @param queries Browser queries.
 * @param opts Options.
 * @returns Array with browser names in Can I Use.
 */
declare function browserslist(
  queries?: string | readonly string[] | null,
  opts?: browserslist.Options
): string[]

declare namespace browserslist {
  interface Query {
    compose: 'or' | 'and'
    type: string
    query: string
    not?: true
  }

  interface Options {
    /**
     * Path to processed file. It will be used to find config files.
     */
    path?: string | false
    /**
     * Processing environment. It will be used to take right queries
     * from config file.
     */
    env?: string
    /**
     * Custom browser usage statistics for "> 1% in my stats" query.
     */
    stats?: Stats | string
    /**
     * Path to config file with queries.
     */
    config?: string
    /**
     * Do not throw on unknown version in direct query.
     */
    ignoreUnknownVersions?: boolean
    /**
     * Throw an error if env is not found.
     */
    throwOnMissing?: boolean
    /**
     * Disable security checks for extend query.
     */
    dangerousExtend?: boolean
    /**
     * Alias mobile browsers to the desktop version when Can I Use
     * doesnâ€™t have data about the specified version.
     */
    mobileToDesktop?: boolean
  }

  type Config = {
    defaults: string[]
    [section: string]: string[] | undefined
  }

  interface Stats {
    [browser: string]: {
      [version: string]: number
    }
  }

  /**
   * Browser names aliases.
   */
  let aliases: {
    [alias: string]: string | undefined
  }

  /**
   * Aliases to work with joined versions like `ios_saf 7.0-7.1`.
   */
  let versionAliases: {
    [browser: string]:
      | {
          [version: string]: string | undefined
        }
      | undefined
  }

  /**
   * Can I Use only provides a few versions for some browsers (e.g. `and_chr`).
   *
   * Fallback to a similar browser for unknown versions.
   */
  let desktopNames: {
    [browser: string]: string | undefined
  }

  let data: {
    [browser: string]:
      | {
          name: string
          versions: string[]
          released: string[]
          releaseDate: {
            [version: string]: number | undefined | null
          }
        }
      | undefined
  }

  let nodeVersions: string[]

  interface Usage {
    [version: string]: number
  }

  let usage: {
    global?: Usage
    custom?: Usage | null
    [country: string]: Usage | undefined | null
  }

  let cache: {
    [feature: string]: {
      [name: string]: 'y' | 'n'
    }
  }

  /**
   * Default browsers query
   */
  let defaults: readonly string[]

  /**
   * Which statistics should be used. Country code or custom statistics.
   * Pass `"my stats"` to load statistics from `Browserslist` files.
   */
  type StatsOptions = string | 'my stats' | Stats | { dataByBrowser: Stats }

  /**
   * Return browsers market coverage.
   *
   * ```js
   * browserslist.coverage(browserslist('> 1% in US'), 'US') //=> 83.1
   * ```
   *
   * @param browsers Browsers names in Can I Use.
   * @param stats Which statistics should be used.
   * @returns Total market coverage for all selected browsers.
   */
  function coverage(browsers: readonly string[], stats?: StatsOptions): number

  /**
   * Get queries AST to analyze the config content.
   *
   * @param queries Browser queries.
   * @param opts Options.
   * @returns An array of the data of each query in the config.
   */
  function parse(
    queries?: string | readonly string[] | null,
    opts?: browserslist.Options
  ): Query[]

  function clearCaches(): void

  function parseConfig(string: string): Config

  function readConfig(file: string): Config

  function findConfig(...pathSegments: string[]): Config | undefined

  interface LoadConfigOptions {
    config?: string
    path?: string
    env?: string
  }

  function loadConfig(options: LoadConfigOptions): string[] | undefined
}

declare global {
  namespace NodeJS {
    interface ProcessEnv {
      BROWSERSLIST?: string
      BROWSERSLIST_CONFIG?: string
      BROWSERSLIST_DANGEROUS_EXTEND?: string
      BROWSERSLIST_DISABLE_CACHE?: string
      BROWSERSLIST_ENV?: string
      BROWSERSLIST_IGNORE_OLD_DATA?: string
      BROWSERSLIST_STATS?: string
    }
  }
}

export = browserslist
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 